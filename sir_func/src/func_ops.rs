use diagnostics::diagnostics::{emit_error, DiagnosticsEmitter, ErrorOrSuccess};
use iostreams::location::Location;
use parse::lexer::TokenValue;
use parse::parser::Parser;
use sir_core::{
    attributes::{Attribute, StringAttr, TypeAttr},
    block::Block,
    ir_builder::OpImplBuilderState,
    ir_context::{IRContext, RawOpBuilder},
    ir_data::{OperationData, ValueID},
    ir_parser::{BlockParserState, IRParsableObject, IRParser, OperationParserState},
    ir_printer::{IRPrintableObject, IRPrinter},
    ir_verifier::ir_checks,
    op_interfaces::{
        BuiltinOp, BuiltinOpInterfaceImpl, BuiltinOpInterfaceImplWrapper, ConstantOp,
        ConstantOpInterfaceImpl, ConstantOpInterfaceImplWrapper, OpInterfaceBuilder,
        OpInterfaceWrapper, SymbolOp, SymbolOpInterfaceImpl, SymbolOpInterfaceImplWrapper,
    },
    op_tags::{TAG_DECLS_BLOCK_OP, TAG_PURE_OP, TAG_TERMINATOR_OP},
    operation::{GenericOperation, OperationImpl},
    operation_type::{OperationTypeBuilder, OperationTypeUID},
    types::{FunctionType, Type},
    value::Value,
};
use sir_interpreter::{
    interfaces::{
        InterpretableOp, InterpretableOpInterfaceImpl, InterpretableOpInterfaceImplWrapper,
    },
    interpreter::{InstructionAddress, SIRInterpreter},
};
use sir_low_level::{
    interfaces::{
        ConditionallyLowLevelOp, ConditionallyLowLevelOpInterfaceImpl,
        ConditionallyLowLevelOpInterfaceImplWrapper,
    },
    low_level_types,
    tags::TAG_LOW_LEVEL_OP,
};

/////////////////////////////////////////////////////////////////////////
// ModuleOp implementation
/////////////////////////////////////////////////////////////////////////

// @XGENDEF:SIROp ModuleOp
// @opname "module"
// @tags ["TAG_DECLS_BLOCK_OP", "TAG_LOW_LEVEL_OP"]
// @+block "body"
// @custom_print_parse
// @disable_default_builder

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const MODULE_OPNAME: &'static str = "module";
const MODULE_TYPE_UID: OperationTypeUID = OperationTypeUID::make_from_opname(MODULE_OPNAME);

pub struct ModuleOp<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for ModuleOp<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        MODULE_TYPE_UID
    }
}

impl<'a> ModuleOp<'a> {
    pub fn get_body(&self) -> Block<'a> {
        self.get_block(0)
    }
}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct ModuleOpBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for ModuleOpBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) -> ErrorOrSuccess {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ModuleOp>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ModuleOp>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        ModuleOp::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        ModuleOp::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for ModuleOpBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> ModuleOp<'a> {
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        ir_checks::verif_inputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 1)?;
        Ok(())
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(ModuleOpBuiltinOpInterfaceImpl))
    }
}

fn register_module_op(ctx: &mut IRContext) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(MODULE_OPNAME);
    infos.set_impl::<ModuleOp>();
    infos.set_builtin_interface::<ModuleOpBuiltinOpInterfaceImpl>();
    infos.set_tags(&[TAG_DECLS_BLOCK_OP, TAG_LOW_LEVEL_OP]);
    infos.add_interface::<ModuleOpBuiltinOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

impl ModuleOp<'_> {
    pub fn build() -> OpImplBuilderState<Self> {
        let st = OpImplBuilderState::make();
        st
    }
}

// BuiltinOp interface implementation.
impl<'a> ModuleOp<'a> {
    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_results_and_opname(self.generic(), true)?;

        let body = self.get_body();
        write!(printer.os(), "{{")?;

        // Print the body
        printer.print_block_content(body)?;
        write!(printer.os(), "}}")
    }

    pub fn custom_parse(
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        let loc_beg = parser.get_next_token_loc();
        parser.consume_sym_or_error(TokenValue::sym_lcbracket())?;

        // Parse the body
        let mut block_st = BlockParserState::new();
        block_st.set_loc(loc_beg);
        let block = parser.make_block_from_state(block_st, ctx, TokenValue::sym_rcbracket())?;

        // Set the block
        st.set_blocks(vec![block]);
        Some(())
    }
}

/////////////////////////////////////////////////////////////////////////
// FunctionOp implementation
/////////////////////////////////////////////////////////////////////////

// @XGENDEF:SIROp FunctionOp
// @opname "function"
// @+attr StringAttr<"symbol_name">
// @+attr FunctionTypeAttr<"function_type">
// @+block "body"
// @interfaces [ConditionallyLowLevelOp, SymbolOp, InterpretableOp]
// @verifier
// @custom_print_parse
// @disable_default_builder

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const FUNCTION_OPNAME: &'static str = "function";
const FUNCTION_TYPE_UID: OperationTypeUID = OperationTypeUID::make_from_opname(FUNCTION_OPNAME);

pub struct FunctionOp<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for FunctionOp<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        FUNCTION_TYPE_UID
    }
}

const FUNCTION_ATTR_SYMBOL_NAME: &'static str = "symbol_name";
const FUNCTION_ATTR_FUNCTION_TYPE: &'static str = "function_type";

impl<'a> FunctionOp<'a> {
    pub fn get_symbol_name(&self) -> &'a str {
        self.get_attr(FUNCTION_ATTR_SYMBOL_NAME)
            .expect("Missing `symbol_name` attribute")
            .cast::<StringAttr>()
            .expect("`symbol_name` attribute must be a StringAttr")
            .val()
    }

    pub fn get_symbol_name_attr(&self) -> &'a Attribute {
        self.get_attr(FUNCTION_ATTR_SYMBOL_NAME)
            .expect("Missing `symbol_name` attribute")
    }

    pub fn get_function_type(&self) -> &'a FunctionType {
        self.get_attr(FUNCTION_ATTR_FUNCTION_TYPE)
            .expect("Missing `function_type` attribute")
            .cast::<TypeAttr>()
            .expect("`function_type` attribute must be a Type")
            .val()
            .cast::<FunctionType>()
            .expect("`function_type` type attribute must be a FunctionType")
    }

    pub fn get_function_type_attr(&self) -> &'a Attribute {
        self.get_attr(FUNCTION_ATTR_FUNCTION_TYPE)
            .expect("Missing `function_type` attribute")
    }

    pub fn get_body(&self) -> Block<'a> {
        self.get_block(0)
    }
}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct FunctionOpBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for FunctionOpBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) -> ErrorOrSuccess {
        GenericOperation::make_from_data(ctx, data)
            .cast::<FunctionOp>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<FunctionOp>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        FunctionOp::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        FunctionOp::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for FunctionOpBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

// Wrapper struct for the ConditionallyLowLevelOp interface implementation.
#[derive(Default)]
pub struct FunctionOpConditionallyLowLevelOpInterfaceImpl;

impl ConditionallyLowLevelOpInterfaceImpl for FunctionOpConditionallyLowLevelOpInterfaceImpl {
    fn is_low_level<'a>(&self, ctx: &'a IRContext, data: &'a OperationData) -> bool {
        GenericOperation::make_from_data(ctx, data)
            .cast::<FunctionOp>()
            .unwrap()
            .is_low_level()
    }
}

// Interface builder for ConditionallyLowLevelOp interface.
impl OpInterfaceBuilder for FunctionOpConditionallyLowLevelOpInterfaceImpl {
    type InterfaceObjectType = ConditionallyLowLevelOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = ConditionallyLowLevelOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

// Wrapper struct for the SymbolOp interface implementation.
#[derive(Default)]
pub struct FunctionOpSymbolOpInterfaceImpl;

impl SymbolOpInterfaceImpl for FunctionOpSymbolOpInterfaceImpl {
    fn get_symbol_name<'a>(&self, ctx: &'a IRContext, data: &'a OperationData) -> &'a str {
        GenericOperation::make_from_data(ctx, data)
            .cast::<FunctionOp>()
            .unwrap()
            .get_symbol_name()
    }
    fn get_symbol_type<'a>(&self, ctx: &'a IRContext, data: &'a OperationData) -> &'a Type {
        GenericOperation::make_from_data(ctx, data)
            .cast::<FunctionOp>()
            .unwrap()
            .get_symbol_type()
    }
}

// Interface builder for SymbolOp interface.
impl OpInterfaceBuilder for FunctionOpSymbolOpInterfaceImpl {
    type InterfaceObjectType = SymbolOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = SymbolOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

// Wrapper struct for the InterpretableOp interface implementation.
#[derive(Default)]
pub struct FunctionOpInterpretableOpInterfaceImpl;

impl InterpretableOpInterfaceImpl for FunctionOpInterpretableOpInterfaceImpl {
    fn interpret<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        interpreter: &mut SIRInterpreter,
    ) {
        GenericOperation::make_from_data(ctx, data)
            .cast::<FunctionOp>()
            .unwrap()
            .interpret(interpreter)
    }
}

// Interface builder for InterpretableOp interface.
impl OpInterfaceBuilder for FunctionOpInterpretableOpInterfaceImpl {
    type InterfaceObjectType = InterpretableOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = InterpretableOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> FunctionOp<'a> {
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        ir_checks::verif_inputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_has_attr_of_type::<StringAttr>(
            diagnostics,
            self.generic(),
            FUNCTION_ATTR_SYMBOL_NAME,
        )?;
        ir_checks::verif_has_type_attr_of_type::<FunctionType>(
            diagnostics,
            self.generic(),
            FUNCTION_ATTR_FUNCTION_TYPE,
        )?;
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 1)?;
        self.verify_op(diagnostics)?;
        Ok(())
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(FunctionOpBuiltinOpInterfaceImpl))
    }
}

fn register_function_op(ctx: &mut IRContext) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(FUNCTION_OPNAME);
    infos.set_impl::<FunctionOp>();
    infos.set_builtin_interface::<FunctionOpBuiltinOpInterfaceImpl>();
    infos.add_interface::<FunctionOpBuiltinOpInterfaceImpl>();
    infos.add_interface::<FunctionOpConditionallyLowLevelOpInterfaceImpl>();
    infos.add_interface::<FunctionOpSymbolOpInterfaceImpl>();
    infos.add_interface::<FunctionOpInterpretableOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

impl FunctionOp<'_> {
    pub fn build<S: Into<StringAttr>>(
        symbol_name: S,
        function_type: Type,
    ) -> OpImplBuilderState<Self> {
        let symbol_name = Attribute::Str(symbol_name.into());
        assert!(function_type.isa::<FunctionType>());
        let function_type = TypeAttr::new(function_type);
        let mut st = OpImplBuilderState::make();
        st.set_attr(FUNCTION_ATTR_SYMBOL_NAME, symbol_name);
        st.set_attr(FUNCTION_ATTR_FUNCTION_TYPE, function_type);
        st
    }
}

// BuiltinOp interface implementation.
impl<'a> FunctionOp<'a> {
    pub fn verify_op(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        // Check the block operands types
        let fun_type = self.get_function_type();
        let body = self.get_body();
        if fun_type.num_arguments() != body.get_num_operands() {
            emit_error(diagnostics, &self.generic(), format!("Signature type mismatch: signature has {} operands but body block has {} operands", fun_type.num_arguments(), body.get_num_operands()));
            return Err(());
        }

        for (idx, (fun_ty, block_ty)) in fun_type
            .arguments()
            .iter()
            .zip(body.get_operands_types())
            .enumerate()
        {
            if fun_ty != block_ty {
                emit_error(diagnostics, &self.generic(), format!("Signature type mismatch: block operand #{} has type {} but function signature operand type is {}", idx, block_ty.to_string_repr(), fun_ty.to_string_repr()));
                return Err(());
            }
        }

        Ok(())
    }

    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_results_and_opname(self.generic(), true)?;

        // Print the symbol name.
        write!(printer.os(), "@{}", self.get_symbol_name())?;

        let body = self.get_body();
        // Print the arguments
        write!(printer.os(), "(")?;
        printer.start_printing_block();
        for (idx, arg) in body.get_operands().enumerate() {
            printer.assign_and_print_value_label(arg.as_id(), true)?;
            write!(printer.os(), ": ")?;
            printer.print(arg.get_type())?;
            if idx + 1 < body.get_num_operands() {
                write!(printer.os(), ", ")?;
            }
        }
        write!(printer.os(), ")")?;

        // Print the optional results.
        let fun_type = self.get_function_type();
        if fun_type.num_results() > 0 {
            write!(printer.os(), " -> (")?;
            for (idx, ty) in fun_type.results().iter().enumerate() {
                printer.print(ty)?;
                if idx + 1 < fun_type.num_results() {
                    write!(printer.os(), ", ")?;
                }
            }
            write!(printer.os(), ")")?;
        }

        // Print the body
        write!(printer.os(), " {{")?;
        printer.print_block_content(body)?;
        printer.end_printing_block();
        write!(printer.os(), "}}")
    }

    pub fn custom_parse(
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        // Parse the symbol name.
        parser.consume_sym_or_error(TokenValue::sym_at())?;
        let symbol_name = parser
            .consume_identifier_or_error()?
            .take_identifier()
            .unwrap();
        st.set_attr(FUNCTION_ATTR_SYMBOL_NAME, StringAttr::new(symbol_name));

        let mut block_st = BlockParserState::new();
        // Parse the arguments.
        let loc_beg = parser.get_next_token_loc();
        let mut operands_names = vec![];
        let mut operands_types = vec![];
        parser.consume_sym_or_error(TokenValue::sym_lparen())?;
        if !parser.next_token_is_sym(TokenValue::sym_rparen()) {
            loop {
                operands_names.push(parser.parse_value_ref()?);
                parser.consume_sym_or_error(TokenValue::sym_colon())?;
                operands_types.push(Type::parse(parser)?);
                if !parser.try_consume_sym(TokenValue::sym_comma()) {
                    break;
                }
            }
        }
        parser.consume_sym_or_error(TokenValue::sym_rparen())?;
        block_st.set_operands_names(operands_names);
        block_st.set_operands_types(operands_types.clone());

        // Parse the optional result types.
        // '->' '(' <type> ',' <type> ',' ... ')'
        let mut results_types = Vec::new();
        if parser.try_consume_sym(TokenValue::sym_deref()) {
            parser.consume_sym_or_error(TokenValue::sym_lparen())?;
            if !parser.next_token_is_sym(TokenValue::sym_rparen()) {
                loop {
                    results_types.push(Type::parse(parser)?);
                    if !parser.try_consume_sym(TokenValue::sym_comma()) {
                        break;
                    }
                }
            }
            parser.consume_sym_or_error(TokenValue::sym_rparen())?;
        }

        // Build the function type.
        let fun_type = FunctionType::new(operands_types, results_types);
        st.set_attr(FUNCTION_ATTR_FUNCTION_TYPE, TypeAttr::new(fun_type));

        // Parse the body
        let loc_end = parser
            .consume_sym_or_error(TokenValue::sym_lcbracket())?
            .loc();
        block_st.set_loc(Location::join(loc_beg, loc_end));
        let block = parser.make_block_from_state(block_st, ctx, TokenValue::sym_rcbracket())?;

        // Set the block
        st.set_blocks(vec![block]);
        Some(())
    }
}

// ConditionallyLowLevelOp interface implementation
impl<'a> FunctionOp<'a> {
    pub fn is_low_level(&self) -> bool {
        // The function is valid if the function type is valid.
        // Otherwise we'll need to lower it.
        low_level_types::is_valid_function_type(self.get_function_type())
    }
}

// SymbolOp interface implementation
impl<'a> FunctionOp<'a> {
    pub fn get_symbol_type(&self) -> &'a Type {
        self.get_attr(FUNCTION_ATTR_FUNCTION_TYPE)
            .expect("Missing `function_type` attribute")
            .cast::<TypeAttr>()
            .expect("`function_type` attribute must be a Type")
            .val()
    }
}

// InterpretableOp interface implementation.
impl<'a> FunctionOp<'a> {
    pub fn interpret(&self, interpreter: &mut SIRInterpreter) {
        // Prepare the inputs.
        let inputs_attrs = interpreter.take_function_inputs();
        let block = self.get_body();
        if inputs_attrs.len() != block.get_num_operands() {
            panic!(
                "Invalid call to function `{}`: expected {} inputs, but got {}",
                self.get_symbol_name(),
                block.get_num_operands(),
                inputs_attrs.len()
            );
        }
        for (input_val, input_attr) in block.get_operands().zip(inputs_attrs) {
            interpreter.set_value(input_val, input_attr);
        }

        // Set the executor to the start of the function.
        interpreter.set_pc(InstructionAddress::Operation(
            block.get_ops().next().unwrap().as_id(),
        ));
    }
}

/////////////////////////////////////////////////////////////////////////
// ReturnOp implementation
/////////////////////////////////////////////////////////////////////////

// @XGENDEF:SIROp ReturnOp
// @opname "return"
// @+input VariadicValue<"returns">
// @tags ["TAG_TERMINATOR_OP", "TAG_LOW_LEVEL_OP"]
// @interfaces [InterpretableOp]
// @verifier
// @custom_print_parse
// @disable_default_builder

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const RETURN_OPNAME: &'static str = "return";
const RETURN_TYPE_UID: OperationTypeUID = OperationTypeUID::make_from_opname(RETURN_OPNAME);

pub struct ReturnOp<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for ReturnOp<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        RETURN_TYPE_UID
    }
}

impl<'a> ReturnOp<'a> {}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct ReturnOpBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for ReturnOpBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) -> ErrorOrSuccess {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ReturnOp>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ReturnOp>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        ReturnOp::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        ReturnOp::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for ReturnOpBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

// Wrapper struct for the InterpretableOp interface implementation.
#[derive(Default)]
pub struct ReturnOpInterpretableOpInterfaceImpl;

impl InterpretableOpInterfaceImpl for ReturnOpInterpretableOpInterfaceImpl {
    fn interpret<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        interpreter: &mut SIRInterpreter,
    ) {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ReturnOp>()
            .unwrap()
            .interpret(interpreter)
    }
}

// Interface builder for InterpretableOp interface.
impl OpInterfaceBuilder for ReturnOpInterpretableOpInterfaceImpl {
    type InterfaceObjectType = InterpretableOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = InterpretableOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> ReturnOp<'a> {
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 0)?;
        self.verify_op(diagnostics)?;
        Ok(())
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(ReturnOpBuiltinOpInterfaceImpl))
    }
}

fn register_return_op(ctx: &mut IRContext) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(RETURN_OPNAME);
    infos.set_impl::<ReturnOp>();
    infos.set_builtin_interface::<ReturnOpBuiltinOpInterfaceImpl>();
    infos.set_tags(&[TAG_TERMINATOR_OP, TAG_LOW_LEVEL_OP]);
    infos.add_interface::<ReturnOpBuiltinOpInterfaceImpl>();
    infos.add_interface::<ReturnOpInterpretableOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

impl ReturnOp<'_> {
    pub fn build<T: Into<Vec<ValueID>>>(operands: T) -> OpImplBuilderState<Self> {
        let mut st = OpImplBuilderState::make();
        st.set_inputs(operands);
        st
    }
}

// BuiltinOp interface implementation.
impl<'a> ReturnOp<'a> {
    pub fn verify_op(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        // Get the function signature of the parent.
        let fun_op = match self.parent_op() {
            Some(x) => x,
            None => return Ok(()),
        };
        let fun_type = match fun_op.cast::<FunctionOp>() {
            Some(fun_op) => fun_op.get_function_type(),
            None => {
                emit_error(
                    diagnostics,
                    &self.generic(),
                    format!("ReturnOp parent must be a FunctionOp"),
                );
                return Err(());
            }
        };

        // Check the number and types of the arguments.
        if fun_type.num_results() != self.get_num_inputs() {
            emit_error(
                diagnostics,
                &self.generic(),
                format!(
                    "Function signature has {} results, but the function returns {} values",
                    fun_type.num_results(),
                    self.get_num_inputs()
                ),
            );
            return Err(());
        }
        for (idx, (fun_ty, ret_ty)) in fun_type
            .results()
            .iter()
            .zip(self.get_inputs_types())
            .enumerate()
        {
            if fun_ty != ret_ty {
                emit_error(diagnostics, &self.generic(), format!("Function signature result type #{} is {}, but the return value #{} is of type {}", 
                    idx, fun_ty.to_string_repr(), idx, ret_ty.to_string_repr()));
                return Err(());
            }
        }

        Ok(())
    }

    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_results_and_opname(self.generic(), true)?;

        // Print the return names.
        for (idx, val) in self.get_inputs().enumerate() {
            printer.print_value_label_or_unknown(val.into())?;
            if idx + 1 < self.get_num_outputs() {
                write!(printer.os(), ", ")?;
            }
        }
        write!(printer.os(), " : ")?;

        // Print the return types.
        for (idx, ty) in self.get_inputs_types().enumerate() {
            printer.print(ty)?;
            if idx + 1 < self.get_num_outputs() {
                write!(printer.os(), ", ")?;
            }
        }

        Ok(())
    }

    pub fn custom_parse(
        parser: &mut IRParser,
        _ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        // Parse the operands names.
        let mut inputs_names = vec![];
        if parser.next_token_is_sym(TokenValue::sym_percent()) {
            loop {
                inputs_names.push(parser.parse_value_ref()?);
                if !parser.try_consume_sym(TokenValue::sym_comma()) {
                    break;
                }
            }
            parser.consume_sym_or_error(TokenValue::sym_colon())?;
        }

        // Parse operands types.
        let mut inputs_types = vec![];
        for idx in 0..inputs_names.len() {
            inputs_types.push(Type::parse(parser)?);
            if idx + 1 < inputs_names.len() {
                parser.consume_sym_or_error(TokenValue::sym_comma())?;
            }
        }

        st.set_inputs_names(inputs_names);
        st.set_inputs_types(inputs_types);
        Some(())
    }
}

// InterpretableOp interface implementation.
impl<'a> ReturnOp<'a> {
    pub fn interpret(&self, interpreter: &mut SIRInterpreter) {
        // Assign the outputs.
        let outputs: Vec<Attribute> = self
            .get_inputs()
            .map(|x| interpreter.get_value(x).clone())
            .collect();
        interpreter.set_function_outputs(outputs);

        // Return from the function.
        interpreter.pop_call_frame();
    }
}

/////////////////////////////////////////////////////////////////////////
// ConstantOp implementation
/////////////////////////////////////////////////////////////////////////

// @TODO[I5][SIR-FUNC]: Consider moving GenericConstantOp to another lib.
// @TODO[I6][SIR-FUNC]: Replace math.constant with generic.constant.

// @XGENDEF:SIROp GenericConstantOp
// @opname "generic.constant"
// @+attr AnyAttr<"value">
// @+output ValueWithPred<"result", PredMatchTypeOfAttr<"value">, "same type than value">
// @tags ["TAG_PURE_OP", "TAG_LOW_LEVEL_OP"]
// @interfaces [ConstantOp]
// @custom_print_parse
// @disable_default_builder
// @constant_builder

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const GENERIC_CONSTANT_OPNAME: &'static str = "generic.constant";
const GENERIC_CONSTANT_TYPE_UID: OperationTypeUID =
    OperationTypeUID::make_from_opname(GENERIC_CONSTANT_OPNAME);

pub struct GenericConstantOp<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for GenericConstantOp<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        GENERIC_CONSTANT_TYPE_UID
    }
}

const GENERIC_CONSTANT_ATTR_VALUE: &'static str = "value";

impl<'a> GenericConstantOp<'a> {
    pub fn get_result(&self) -> Value<'a> {
        self.get_output(0)
    }

    pub fn get_value(&self) -> &'a Attribute {
        self.get_attr(GENERIC_CONSTANT_ATTR_VALUE)
            .expect("Missing `value` attribute")
    }

    pub fn get_value_attr(&self) -> &'a Attribute {
        self.get_attr(GENERIC_CONSTANT_ATTR_VALUE)
            .expect("Missing `value` attribute")
    }
}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct GenericConstantOpBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for GenericConstantOpBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) -> ErrorOrSuccess {
        GenericOperation::make_from_data(ctx, data)
            .cast::<GenericConstantOp>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<GenericConstantOp>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        GenericConstantOp::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        GenericConstantOp::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for GenericConstantOpBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

// Wrapper struct for the ConstantOp interface implementation.
#[derive(Default)]
pub struct GenericConstantOpConstantOpInterfaceImpl;

impl ConstantOpInterfaceImpl for GenericConstantOpConstantOpInterfaceImpl {
    fn get_value<'a>(&self, ctx: &'a IRContext, data: &'a OperationData) -> &'a Attribute {
        GenericOperation::make_from_data(ctx, data)
            .cast::<GenericConstantOp>()
            .unwrap()
            .get_value()
    }
}

// Interface builder for ConstantOp interface.
impl OpInterfaceBuilder for GenericConstantOpConstantOpInterfaceImpl {
    type InterfaceObjectType = ConstantOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = ConstantOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> GenericConstantOp<'a> {
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        ir_checks::verif_inputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_has_attr(diagnostics, self.generic(), GENERIC_CONSTANT_ATTR_VALUE)?;
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 1)?;
        ir_checks::verif_io_type(
            diagnostics,
            self.generic(),
            false,
            0,
            "result",
            |ty| ir_checks::pred_match_type_of_attr(&self.generic(), ty, "value"),
            "same type than value",
        )?;
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 0)?;
        Ok(())
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(GenericConstantOpBuiltinOpInterfaceImpl))
    }
}

fn register_generic_constant_op(ctx: &mut IRContext) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(GENERIC_CONSTANT_OPNAME);
    infos.set_impl::<GenericConstantOp>();
    infos.set_builtin_interface::<GenericConstantOpBuiltinOpInterfaceImpl>();
    infos.set_tags(&[TAG_PURE_OP, TAG_LOW_LEVEL_OP]);
    infos.add_interface::<GenericConstantOpBuiltinOpInterfaceImpl>();
    infos.add_interface::<GenericConstantOpConstantOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

impl<'a> GenericConstantOp<'a> {
    // Op Builders
    pub fn build(val: Attribute) -> OpImplBuilderState<Self> {
        let mut st = OpImplBuilderState::make();
        st.set_inputs(vec![]);
        st.set_outputs_types(vec![val
            .get_type()
            .expect("val must be a typed attr")
            .clone()]);
        st.set_attr(GENERIC_CONSTANT_ATTR_VALUE, val);
        st
    }

    pub fn build_constant(val: Attribute) -> Option<RawOpBuilder> {
        let mut st = RawOpBuilder::new();
        st.set_op_type::<GenericConstantOp>();
        st.set_inputs(vec![]);
        st.set_outputs_types(vec![val
            .get_type()
            .expect("val must be a typed attr")
            .clone()]);
        st.set_attr(GENERIC_CONSTANT_ATTR_VALUE, val);
        Some(st)
    }

    // BuiltinOp interface implementation.
    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_results_and_opname(self.generic(), true)?;

        // Print the attribute
        printer.print(self.get_value())
    }

    pub fn custom_parse(
        parser: &mut IRParser,
        _ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        // Parse the val attribute.
        let val: Attribute = parser.parse()?;
        let ty = val.get_type().expect("`val` must be a typed attr").clone();
        st.set_attr(GENERIC_CONSTANT_ATTR_VALUE, val);
        st.set_outputs_types(vec![ty]);
        Some(())
    }
}

/////////////////////////////////////////////////////////////////////////
// FuncOps Registrations
/////////////////////////////////////////////////////////////////////////

// @XGENBEGIN RegisterOps register_func_ops
pub fn register_func_ops(ctx: &mut IRContext) {
    register_module_op(ctx);
    register_function_op(ctx);
    register_return_op(ctx);
    register_generic_constant_op(ctx);
    ctx.register_constant_builder(GenericConstantOp::build_constant);
}

// @XGENEND
