use diagnostics::diagnostics::{emit_error, DiagnosticsEmitter, ErrorOrSuccess};
use parse::parser::Parser;
use sir_core::{
    attributes::{Attribute, RegisterAttr},
    ir_builder::OpImplBuilderState,
    ir_context::IRContext,
    ir_data::OperationData,
    ir_parser::{IRParser, OperationParserState},
    ir_printer::IRPrinter,
    ir_verifier::ir_checks,
    op_interfaces::{
        BuiltinOp, BuiltinOpInterfaceImpl, BuiltinOpInterfaceImplWrapper, OpInterfaceBuilder,
        OpInterfaceWrapper,
    },
    operation::{GenericOperation, OperationImpl},
    operation_type::{OperationTypeBuilder, OperationTypeUID},
    types::Type,
    value::Value,
};
use sir_transform::context_registry::ContextRegistry;

use crate::ir_verifiers::ir_backend_checks;

/////////////////////////////////////////////////////////////////////////
// Backend BackendRegToValOp implementation
/////////////////////////////////////////////////////////////////////////

// @XGENDEF:SIROp BackendRegToValOp
// @opname "backend.reg_to_val"
// @+attr RegisterAttr<"reg">
// @+output AnyValue<"result">

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const BACKEND_REG_TO_VAL_OPNAME: &'static str = "backend.reg_to_val";
const BACKEND_REG_TO_VAL_TYPE_UID: OperationTypeUID =
    OperationTypeUID::make_from_opname(BACKEND_REG_TO_VAL_OPNAME);

pub struct BackendRegToValOp<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for BackendRegToValOp<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        BACKEND_REG_TO_VAL_TYPE_UID
    }
}

const BACKEND_REG_TO_VAL_ATTR_REG: &'static str = "reg";

impl<'a> BackendRegToValOp<'a> {
    pub fn get_result(&self) -> Value<'a> {
        self.get_output(0)
    }

    pub fn get_reg(&self) -> &'a RegisterAttr {
        self.get_attr(BACKEND_REG_TO_VAL_ATTR_REG)
            .expect("Missing `reg` attribute")
            .cast::<RegisterAttr>()
            .expect("`reg` attribute must be a register attribute")
    }

    pub fn get_reg_attr(&self) -> &'a Attribute {
        self.get_attr(BACKEND_REG_TO_VAL_ATTR_REG)
            .expect("Missing `reg` attribute")
    }
}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct BackendRegToValOpBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for BackendRegToValOpBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) -> ErrorOrSuccess {
        GenericOperation::make_from_data(ctx, data)
            .cast::<BackendRegToValOp>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<BackendRegToValOp>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        BackendRegToValOp::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        BackendRegToValOp::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for BackendRegToValOpBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> BackendRegToValOp<'a> {
    pub fn build(reg: Attribute, result: Type) -> OpImplBuilderState<Self> {
        let mut st = OpImplBuilderState::make();
        st.set_attr(BACKEND_REG_TO_VAL_ATTR_REG, reg);
        st.set_outputs_types(vec![result]);
        st
    }
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        ir_checks::verif_inputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            BACKEND_REG_TO_VAL_ATTR_REG,
            |attr| ir_backend_checks::pred_is_valid_register_attr(self.get_context(), attr),
            "register",
        )?;
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 1)?;
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 0)?;
        Ok(())
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(BackendRegToValOpBuiltinOpInterfaceImpl))
    }

    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_generic_form_impl(self.generic())
    }

    pub fn custom_parse(
        parser: &mut IRParser,
        _ctx: &mut IRContext,
        _st: &mut OperationParserState,
    ) -> Option<()> {
        let loc = parser.get_last_token_loc();
        emit_error(
            parser,
            &loc,
            format!("custom form representation not supported"),
        );
        None
    }
}

fn register_backend_reg_to_val_op(ctx: &mut ContextRegistry) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(BACKEND_REG_TO_VAL_OPNAME);
    infos.set_impl::<BackendRegToValOp>();
    infos.set_builtin_interface::<BackendRegToValOpBuiltinOpInterfaceImpl>();
    infos.add_interface::<BackendRegToValOpBuiltinOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

/////////////////////////////////////////////////////////////////////////
// BackendOps Registrations
/////////////////////////////////////////////////////////////////////////

// @XGENBEGIN RegisterOps register_backend_ops
pub fn register_backend_ops(ctx: &mut IRContext) {
    ContextRegistry::exec_register_fn(ctx, "__sir/ops/register_backend_ops", |mut registry| {
        register_backend_reg_to_val_op(&mut registry);
    });
}

// @XGENEND
