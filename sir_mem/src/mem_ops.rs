use diagnostics::diagnostics::{emit_error, DiagnosticsEmitter, ErrorOrSuccess};
use parse::parser::Parser;
use sir_core::{
    attributes::{Attribute, IntegerAttr},
    ir_builder::OpImplBuilderState,
    ir_context::IRContext,
    ir_data::{OperationData, ValueID},
    ir_parser::{IRParser, OperationParserState},
    ir_printer::{IRPrintableObject, IRPrinter},
    ir_verifier::ir_checks,
    op_interfaces::{
        BuiltinOp, BuiltinOpInterfaceImpl, BuiltinOpInterfaceImplWrapper, OpInterfaceBuilder,
        OpInterfaceWrapper,
    },
    operation::{GenericOperation, OperationImpl},
    operation_type::{OperationTypeBuilder, OperationTypeUID},
    types::{PointerType, Type},
    value::Value,
};

/////////////////////////////////////////////////////////////////////////
// MemLoadOp implementation
/////////////////////////////////////////////////////////////////////////

// @XGENDEF:SIROp MemLoadOp
// @opname "mem.load"
// @+input PointerValue<"ptr">
// @+output AnyValue<"result">
// @verifier

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const MEM_LOAD_OPNAME: &'static str = "mem.load";
const MEM_LOAD_TYPE_UID: OperationTypeUID = OperationTypeUID::make_from_opname(MEM_LOAD_OPNAME);

pub struct MemLoadOp<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for MemLoadOp<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        MEM_LOAD_TYPE_UID
    }
}

impl<'a> MemLoadOp<'a> {
    pub fn get_ptr(&self) -> Value<'a> {
        self.get_input(0)
    }

    pub fn get_result(&self) -> Value<'a> {
        self.get_output(0)
    }
}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct MemLoadOpBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for MemLoadOpBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) -> ErrorOrSuccess {
        GenericOperation::make_from_data(ctx, data)
            .cast::<MemLoadOp>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<MemLoadOp>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        MemLoadOp::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        MemLoadOp::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for MemLoadOpBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> MemLoadOp<'a> {
    pub fn build(ptr: ValueID, result: Type) -> OpImplBuilderState<Self> {
        let mut st = OpImplBuilderState::make();
        st.set_inputs(vec![ptr]);
        st.set_outputs_types(vec![result]);
        st
    }
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        ir_checks::verif_inputs_count(diagnostics, self.generic(), 1)?;
        ir_checks::verif_io_is_of_type::<PointerType>(diagnostics, self.generic(), true, 0, "ptr")?;
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 1)?;
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 0)?;
        self.verify_op(diagnostics)?;
        Ok(())
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(MemLoadOpBuiltinOpInterfaceImpl))
    }

    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_generic_form_impl(self.generic())
    }

    pub fn custom_parse(
        parser: &mut IRParser,
        _ctx: &mut IRContext,
        _st: &mut OperationParserState,
    ) -> Option<()> {
        let loc = parser.get_last_token_loc();
        emit_error(
            parser,
            &loc,
            format!("custom form representation not supported"),
        );
        None
    }
}

fn register_mem_load_op(ctx: &mut IRContext) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(MEM_LOAD_OPNAME);
    infos.set_impl::<MemLoadOp>();
    infos.set_builtin_interface::<MemLoadOpBuiltinOpInterfaceImpl>();
    infos.add_interface::<MemLoadOpBuiltinOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

// BuiltinImplementation for MemLoadOp
impl<'a> MemLoadOp<'a> {
    pub fn verify_op(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        let ptr_elem_ty = self
            .get_ptr()
            .get_type()
            .cast::<PointerType>()
            .unwrap()
            .element();
        let val_ty = self.get_result().get_type();
        if ptr_elem_ty != val_ty {
            emit_error(
                diagnostics,
                &self.generic(),
                format!(
                    "Pointer element type {} differs from value type {}",
                    ptr_elem_ty.to_string_repr(),
                    val_ty.to_string_repr()
                ),
            );
            return Err(());
        }

        Ok(())
    }
}

/////////////////////////////////////////////////////////////////////////
// MemStoreOp implementation
/////////////////////////////////////////////////////////////////////////

// @XGENDEF:SIROp MemStoreOp
// @opname "mem.store"
// @+input AnyValue<"value">
// @+input PointerValue<"ptr">
// @verifier

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const MEM_STORE_OPNAME: &'static str = "mem.store";
const MEM_STORE_TYPE_UID: OperationTypeUID = OperationTypeUID::make_from_opname(MEM_STORE_OPNAME);

pub struct MemStoreOp<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for MemStoreOp<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        MEM_STORE_TYPE_UID
    }
}

impl<'a> MemStoreOp<'a> {
    pub fn get_value(&self) -> Value<'a> {
        self.get_input(0)
    }

    pub fn get_ptr(&self) -> Value<'a> {
        self.get_input(1)
    }
}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct MemStoreOpBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for MemStoreOpBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) -> ErrorOrSuccess {
        GenericOperation::make_from_data(ctx, data)
            .cast::<MemStoreOp>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<MemStoreOp>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        MemStoreOp::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        MemStoreOp::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for MemStoreOpBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> MemStoreOp<'a> {
    pub fn build(value: ValueID, ptr: ValueID) -> OpImplBuilderState<Self> {
        let mut st = OpImplBuilderState::make();
        st.set_inputs(vec![value, ptr]);
        st
    }
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        ir_checks::verif_inputs_count(diagnostics, self.generic(), 2)?;
        ir_checks::verif_io_is_of_type::<PointerType>(diagnostics, self.generic(), true, 1, "ptr")?;
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 0)?;
        self.verify_op(diagnostics)?;
        Ok(())
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(MemStoreOpBuiltinOpInterfaceImpl))
    }

    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_generic_form_impl(self.generic())
    }

    pub fn custom_parse(
        parser: &mut IRParser,
        _ctx: &mut IRContext,
        _st: &mut OperationParserState,
    ) -> Option<()> {
        let loc = parser.get_last_token_loc();
        emit_error(
            parser,
            &loc,
            format!("custom form representation not supported"),
        );
        None
    }
}

fn register_mem_store_op(ctx: &mut IRContext) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(MEM_STORE_OPNAME);
    infos.set_impl::<MemStoreOp>();
    infos.set_builtin_interface::<MemStoreOpBuiltinOpInterfaceImpl>();
    infos.add_interface::<MemStoreOpBuiltinOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

// BuiltinImplementation for MemStoreOp
impl<'a> MemStoreOp<'a> {
    pub fn verify_op(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        let ptr_elem_ty = self
            .get_ptr()
            .get_type()
            .cast::<PointerType>()
            .unwrap()
            .element();
        let val_ty = self.get_value().get_type();
        if ptr_elem_ty != val_ty {
            emit_error(
                diagnostics,
                &self.generic(),
                format!(
                    "Pointer element type {} differs from value type {}",
                    ptr_elem_ty.to_string_repr(),
                    val_ty.to_string_repr()
                ),
            );
            return Err(());
        }

        Ok(())
    }
}

/////////////////////////////////////////////////////////////////////////
// MemAllocaOp implementation
/////////////////////////////////////////////////////////////////////////

// @XGENDEF:SIROp MemAllocaOp
// @opname "mem.alloca"
// @+attr IndexAttr<"align">
// @+output PointerValue<"result">

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const MEM_ALLOCA_OPNAME: &'static str = "mem.alloca";
const MEM_ALLOCA_TYPE_UID: OperationTypeUID = OperationTypeUID::make_from_opname(MEM_ALLOCA_OPNAME);

pub struct MemAllocaOp<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for MemAllocaOp<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        MEM_ALLOCA_TYPE_UID
    }
}

const MEM_ALLOCA_ATTR_ALIGN: &'static str = "align";

impl<'a> MemAllocaOp<'a> {
    pub fn get_result(&self) -> Value<'a> {
        self.get_output(0)
    }

    pub fn get_align(&self) -> u64 {
        self.get_attr(MEM_ALLOCA_ATTR_ALIGN)
            .expect("Missing `align` attribute")
            .cast::<IntegerAttr>()
            .expect("`align` attribute must be an IntegerType")
            .raw_val()
    }

    pub fn get_align_attr(&self) -> &'a Attribute {
        self.get_attr(MEM_ALLOCA_ATTR_ALIGN)
            .expect("Missing `align` attribute")
    }
}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct MemAllocaOpBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for MemAllocaOpBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) -> ErrorOrSuccess {
        GenericOperation::make_from_data(ctx, data)
            .cast::<MemAllocaOp>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<MemAllocaOp>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        MemAllocaOp::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        MemAllocaOp::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for MemAllocaOpBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> MemAllocaOp<'a> {
    pub fn build(align: Attribute, result: Type) -> OpImplBuilderState<Self> {
        let mut st = OpImplBuilderState::make();
        st.set_attr(MEM_ALLOCA_ATTR_ALIGN, align);
        st.set_outputs_types(vec![result]);
        st
    }
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        ir_checks::verif_inputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            MEM_ALLOCA_ATTR_ALIGN,
            |attr| ir_checks::pred_is_index_attribute(attr),
            "index type",
        )?;
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 1)?;
        ir_checks::verif_io_is_of_type::<PointerType>(
            diagnostics,
            self.generic(),
            false,
            0,
            "result",
        )?;
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 0)?;
        Ok(())
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(MemAllocaOpBuiltinOpInterfaceImpl))
    }

    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_generic_form_impl(self.generic())
    }

    pub fn custom_parse(
        parser: &mut IRParser,
        _ctx: &mut IRContext,
        _st: &mut OperationParserState,
    ) -> Option<()> {
        let loc = parser.get_last_token_loc();
        emit_error(
            parser,
            &loc,
            format!("custom form representation not supported"),
        );
        None
    }
}

fn register_mem_alloca_op(ctx: &mut IRContext) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(MEM_ALLOCA_OPNAME);
    infos.set_impl::<MemAllocaOp>();
    infos.set_builtin_interface::<MemAllocaOpBuiltinOpInterfaceImpl>();
    infos.add_interface::<MemAllocaOpBuiltinOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

/////////////////////////////////////////////////////////////////////////
// MemOps Registrations
/////////////////////////////////////////////////////////////////////////

// @XGENBEGIN RegisterOps register_mem_ops
pub fn register_mem_ops(ctx: &mut IRContext) {
    register_mem_load_op(ctx);
    register_mem_store_op(ctx);
    register_mem_alloca_op(ctx);
}

// @XGENEND
