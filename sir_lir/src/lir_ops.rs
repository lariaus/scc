use diagnostics::diagnostics::DiagnosticsEmitter;
use parse::lexer::TokenValue;
use parse::parser::Parser;
use sir_core::{
    ir_builder::OpImplBuilderState,
    ir_context::IRContext,
    ir_data::{OperationData, ValueID},
    ir_parser::{IRParsableObject, IRParser, OperationParserState},
    ir_printer::IRPrinter,
    ir_verifier::ir_checks,
    op_interfaces::{
        BuiltinOp, BuiltinOpInterfaceImpl, BuiltinOpInterfaceImplWrapper, OpInterfaceBuilder,
        OpInterfaceWrapper,
    },
    op_tags::TAG_PURE_OP,
    operation::{GenericOperation, OperationImpl},
    operation_type::{OperationTypeBuilder, OperationTypeUID},
    types::Type,
    value::Value,
};
use sir_low_level::{low_level_types, tags::TAG_LOW_LEVEL_OP};

/////////////////////////////////////////////////////////////////////////
// LIRType implementation
/////////////////////////////////////////////////////////////////////////

// Predicate function that value is a scalar
// @XGENDEF PredIsLIRScalarType = {{ low_level_types::is_valid_scalar_type(ty) }}

// Predicate function that value is a scalar integer
// @XGENDEF PredIsLIRScalarIntType = {{ low_level_types::pred_valid_scalar_int_type(ty) }}

// Predicate function that value is a scalar floating point
// @XGENDEF PredIsLIRScalarFloatType = {{ low_level_types::pred_valid_scalar_float_type(ty) }}

// LIR Scalar Value
// @XGENDEF LIRScalarValue<Name> : ValueWithPred<Name, PredIsLIRScalarType, "LIR scalar">

// LIR Int Scalar Value
// @XGENDEF LIRIntScalarValue<Name> : ValueWithPred<Name, PredIsLIRScalarIntType, "LIR integer scalar">

// LIR Float Scalar Value
// @XGENDEF LIRFloatScalarValue<Name> : ValueWithPred<Name, PredIsLIRScalarFloatType, "LIR floating point scalar">

/////////////////////////////////////////////////////////////////////////
// LIRIAddOp implementation
/////////////////////////////////////////////////////////////////////////

// @XGENDEF:SIROp LIRIAddOp
// @opname "lir.iadd"
// @+input LIRIntScalarValue<"lhs">
// @+input LIRIntScalarValue<"rhs">
// @+output LIRIntScalarValue<"result">
// @tags ["TAG_PURE_OP", "TAG_LOW_LEVEL_OP"]
// @+mod SameInputsAndOutputsTypes
// @custom_print_parse

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const L_I_R_I_ADD_OPNAME: &'static str = "lir.iadd";
const L_I_R_I_ADD_TYPE_UID: OperationTypeUID =
    OperationTypeUID::make_from_opname(L_I_R_I_ADD_OPNAME);

pub struct LIRIAddOp<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for LIRIAddOp<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        L_I_R_I_ADD_TYPE_UID
    }
}

impl<'a> LIRIAddOp<'a> {
    pub fn get_lhs(&self) -> Value<'a> {
        self.get_input(0)
    }

    pub fn get_rhs(&self) -> Value<'a> {
        self.get_input(1)
    }

    pub fn get_result(&self) -> Value<'a> {
        self.get_output(0)
    }
}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct LIRIAddOpBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for LIRIAddOpBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) {
        GenericOperation::make_from_data(ctx, data)
            .cast::<LIRIAddOp>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<LIRIAddOp>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        LIRIAddOp::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        LIRIAddOp::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for LIRIAddOpBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> LIRIAddOp<'a> {
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) {
        ir_checks::verif_inputs_count(diagnostics, self.generic(), 2);
        ir_checks::verif_io_type(
            diagnostics,
            self.generic(),
            true,
            0,
            "lhs",
            |ty| low_level_types::pred_valid_scalar_int_type(ty),
            "LIR integer scalar",
        );
        ir_checks::verif_io_type(
            diagnostics,
            self.generic(),
            true,
            1,
            "rhs",
            |ty| low_level_types::pred_valid_scalar_int_type(ty),
            "LIR integer scalar",
        );
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 1);
        ir_checks::verif_io_type(
            diagnostics,
            self.generic(),
            false,
            0,
            "result",
            |ty| low_level_types::pred_valid_scalar_int_type(ty),
            "LIR integer scalar",
        );
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 0);
        ir_checks::verif_same_input_output_types(diagnostics, self.generic());
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(LIRIAddOpBuiltinOpInterfaceImpl))
    }
}

fn register_l_i_r_i_add_op(ctx: &mut IRContext) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(L_I_R_I_ADD_OPNAME);
    infos.set_impl::<LIRIAddOp>();
    infos.set_builtin_interface::<LIRIAddOpBuiltinOpInterfaceImpl>();
    infos.set_tags(&[TAG_PURE_OP, TAG_LOW_LEVEL_OP]);
    infos.add_interface::<LIRIAddOpBuiltinOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

impl LIRIAddOp<'_> {
    pub fn build<T0: Into<ValueID>, T1: Into<ValueID>>(
        lhs: T0,
        rhs: T1,
        out: Type,
    ) -> OpImplBuilderState<Self> {
        let mut st = OpImplBuilderState::make();
        st.set_inputs(vec![lhs.into(), rhs.into()]);
        st.set_outputs_types(vec![out]);
        st
    }

    // pub fn build_generic<InputsValues: Into<Vec<ValueID>>,
    //                      OutputsTypes: Into<Vec<Type>>,
    //                      Attrs: Into<DictAttr>,
    //                      Blocks: Into<Vec<BlockID>>>(
    //     inputs: InputsValues,
    //     outputs_types: OutputsTypes,
    //     attrs_dict: Attrs,
    //     blocks: Blocks,
    // ) -> OpImplBuilderState<Self> {
    //     let mut st = OpImplBuilderState::make();
    //     st.set_inputs(inputs);
    //     st.set_outputs_types(outputs_types);
    //     st.set_attrs_dict(attrs_dict);
    //     st.set_blocks(blocks);
    //     st
    // }
}

// BuiltinOp interface implementation.
impl<'a> LIRIAddOp<'a> {
    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_results_and_opname(self.generic(), true)?;

        printer.print_value_label_or_unknown(self.get_lhs().into())?;
        write!(printer.os(), ", ")?;
        printer.print_value_label_or_unknown(self.get_rhs().into())?;
        write!(printer.os(), " : ")?;
        printer.print(self.get_result().get_type())
    }

    pub fn custom_parse(
        parser: &mut IRParser,
        _ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        // Parse the two op inputs.
        let mut inputs_names = vec![];
        inputs_names.push(parser.parse_value_ref()?);
        parser.consume_sym_or_error(TokenValue::sym_comma())?;
        inputs_names.push(parser.parse_value_ref()?);

        // Parse the type (same for I/Os).
        let mut inputs_types = vec![];
        let mut outputs_types = vec![];
        parser.consume_sym_or_error(TokenValue::sym_colon())?;
        let ty = Type::parse(parser)?;
        inputs_types.push(ty.clone());
        inputs_types.push(ty.clone());
        outputs_types.push(ty);
        st.set_inputs_names(inputs_names);
        st.set_inputs_types(inputs_types);
        st.set_outputs_types(outputs_types);
        Some(())
    }
}

/////////////////////////////////////////////////////////////////////////
// LIROps Registrations
/////////////////////////////////////////////////////////////////////////

// @XGENBEGIN RegisterOps register_lir_ops
pub fn register_lir_ops(ctx: &mut IRContext) {
    register_l_i_r_i_add_op(ctx);
}

// @XGENEND
