use diagnostics::diagnostics::{DiagnosticsEmitter, ErrorOrSuccess};
use parse::lexer::TokenValue;
use parse::parser::Parser;
use sir_backend::{
    custom_ir::{
        parse_short_form_register, parse_short_form_register_or_immediate,
        print_short_form_register, print_short_form_register_or_immediate,
    },
    ir_verifiers::ir_backend_checks,
};
use sir_core::{
    attributes::{ArrayAttr, Attribute, IntegerAttr, RegisterAttr, StringAttr},
    block::Block,
    ir_builder::OpImplBuilderState,
    ir_context::IRContext,
    ir_data::OperationData,
    ir_parser::{BlockParserState, IRParser, OperationParserState},
    ir_printer::IRPrinter,
    ir_verifier::ir_checks,
    op_interfaces::{
        BuiltinOp, BuiltinOpInterfaceImpl, BuiltinOpInterfaceImplWrapper, OpInterfaceBuilder,
        OpInterfaceWrapper,
    },
    op_tags::TAG_TERMINATOR_OP,
    operation::{GenericOperation, OperationImpl},
    operation_type::{OperationTypeBuilder, OperationTypeUID},
    types::IntegerType,
};
use sir_transform::context_registry::ContextRegistry;

/////////////////////////////////////////////////////////////////////////
// ArmProcOp implementation
/////////////////////////////////////////////////////////////////////////

// @XGENDEF:SIROp ArmProcOp
// @opname "arm.proc"
// @+attr StringAttr<"symbol_name">
// @+attr Optional<RegisterListAttr<"inputs_regs">>
// @+attr Optional<RegisterListAttr<"outputs_regs">>
// @+attr Optional<IndexAttr<"frame_size">>
// @+block "body"
// @custom_print_parse
// @disable_default_builder

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const ARM_PROC_OPNAME: &'static str = "arm.proc";
const ARM_PROC_TYPE_UID: OperationTypeUID = OperationTypeUID::make_from_opname(ARM_PROC_OPNAME);

pub struct ArmProcOp<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for ArmProcOp<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        ARM_PROC_TYPE_UID
    }
}

const ARM_PROC_ATTR_SYMBOL_NAME: &'static str = "symbol_name";
const ARM_PROC_ATTR_INPUTS_REGS: &'static str = "inputs_regs";
const ARM_PROC_ATTR_OUTPUTS_REGS: &'static str = "outputs_regs";
const ARM_PROC_ATTR_FRAME_SIZE: &'static str = "frame_size";

impl<'a> ArmProcOp<'a> {
    pub fn get_symbol_name(&self) -> &'a str {
        self.get_attr(ARM_PROC_ATTR_SYMBOL_NAME)
            .expect("Missing `symbol_name` attribute")
            .cast::<StringAttr>()
            .expect("`symbol_name` attribute must be a StringAttr")
            .val()
    }

    pub fn get_symbol_name_attr(&self) -> &'a Attribute {
        self.get_attr(ARM_PROC_ATTR_SYMBOL_NAME)
            .expect("Missing `symbol_name` attribute")
    }

    pub fn get_inputs_regs(&self) -> Option<&'a Attribute> {
        if self.has_attr(ARM_PROC_ATTR_INPUTS_REGS) {
            Some(
                self.get_attr(ARM_PROC_ATTR_INPUTS_REGS)
                    .expect("Missing `inputs_regs` attribute"),
            )
        } else {
            None
        }
    }

    pub fn get_inputs_regs_attr(&self) -> Option<&'a Attribute> {
        self.get_attr(ARM_PROC_ATTR_INPUTS_REGS)
    }

    pub fn get_outputs_regs(&self) -> Option<&'a Attribute> {
        if self.has_attr(ARM_PROC_ATTR_OUTPUTS_REGS) {
            Some(
                self.get_attr(ARM_PROC_ATTR_OUTPUTS_REGS)
                    .expect("Missing `outputs_regs` attribute"),
            )
        } else {
            None
        }
    }

    pub fn get_outputs_regs_attr(&self) -> Option<&'a Attribute> {
        self.get_attr(ARM_PROC_ATTR_OUTPUTS_REGS)
    }

    pub fn get_frame_size(&self) -> Option<u64> {
        if self.has_attr(ARM_PROC_ATTR_FRAME_SIZE) {
            Some(
                self.get_attr(ARM_PROC_ATTR_FRAME_SIZE)
                    .expect("Missing `frame_size` attribute")
                    .cast::<IntegerAttr>()
                    .expect("`frame_size` attribute must be an IntegerType")
                    .raw_val(),
            )
        } else {
            None
        }
    }

    pub fn get_frame_size_attr(&self) -> Option<&'a Attribute> {
        self.get_attr(ARM_PROC_ATTR_FRAME_SIZE)
    }

    pub fn get_body(&self) -> Block<'a> {
        self.get_block(0)
    }
}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct ArmProcOpBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for ArmProcOpBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) -> ErrorOrSuccess {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ArmProcOp>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ArmProcOp>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        ArmProcOp::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        ArmProcOp::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for ArmProcOpBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> ArmProcOp<'a> {
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        ir_checks::verif_inputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_has_attr_of_type::<StringAttr>(
            diagnostics,
            self.generic(),
            ARM_PROC_ATTR_SYMBOL_NAME,
        )?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_PROC_ATTR_INPUTS_REGS,
            |attr| ir_backend_checks::pred_is_valid_registers_list_attr(self.get_context(), attr),
            "registers list",
        )?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_PROC_ATTR_OUTPUTS_REGS,
            |attr| ir_backend_checks::pred_is_valid_registers_list_attr(self.get_context(), attr),
            "registers list",
        )?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_PROC_ATTR_FRAME_SIZE,
            |attr| ir_checks::pred_is_index_attribute(attr),
            "index type",
        )?;
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 1)?;
        Ok(())
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(ArmProcOpBuiltinOpInterfaceImpl))
    }
}

fn register_arm_proc_op(ctx: &mut ContextRegistry) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(ARM_PROC_OPNAME);
    infos.set_impl::<ArmProcOp>();
    infos.set_builtin_interface::<ArmProcOpBuiltinOpInterfaceImpl>();
    infos.add_interface::<ArmProcOpBuiltinOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

// BuiltinOp interface implementation for ArmProcOp.
impl<'a> ArmProcOp<'a> {
    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_results_and_opname(self.generic(), true)?;

        // Print the symbol name.
        write!(printer.os(), "@{}", self.get_symbol_name())?;

        // Print the optional input regs.
        if let Some(input_regs) = self.get_inputs_regs() {
            let input_regs = input_regs.cast::<ArrayAttr>().unwrap();
            write!(printer.os(), " ins [")?;
            for (idx, reg_attr) in input_regs.elements().iter().enumerate() {
                let reg_attr = reg_attr.cast::<RegisterAttr>().unwrap();
                if idx > 0 {
                    write!(printer.os(), ", ")?;
                }
                print_short_form_register(reg_attr, printer)?;
            }
            write!(printer.os(), "]")?;
        }

        // Print the optional outputs regs.
        if let Some(outputs_regs) = self.get_outputs_regs() {
            let outputs_regs = outputs_regs.cast::<ArrayAttr>().unwrap();
            write!(printer.os(), " outs [")?;
            for (idx, reg_attr) in outputs_regs.elements().iter().enumerate() {
                let reg_attr = reg_attr.cast::<RegisterAttr>().unwrap();
                if idx > 0 {
                    write!(printer.os(), ", ")?;
                }
                print_short_form_register(reg_attr, printer)?;
            }
            write!(printer.os(), "]")?;
        }

        // Print the optional frame size
        if let Some(frame_size) = self.get_frame_size() {
            write!(printer.os(), " frame_size = {}", frame_size)?;
        }

        // Print the body
        let body = self.get_body();
        printer.start_printing_block();
        write!(printer.os(), " {{")?;
        printer.print_block_content(body)?;
        printer.end_printing_block();
        write!(printer.os(), "}}")
    }

    pub fn custom_parse(
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        // Parse the symbol name.
        parser.consume_sym_or_error(TokenValue::sym_at())?;
        let symbol_name = parser
            .consume_identifier_or_error()?
            .take_identifier()
            .unwrap();
        st.set_attr(ARM_PROC_ATTR_SYMBOL_NAME, StringAttr::new(symbol_name));

        // parse the optional inputs registers
        if parser.try_consume_identifier_val("ins") {
            let mut regs = Vec::new();
            parser.consume_sym_or_error(TokenValue::sym_lbracket())?;
            if !parser.next_token_is_sym(TokenValue::sym_rbracket()) {
                loop {
                    regs.push(parse_short_form_register(parser)?);
                    if !parser.try_consume_sym(TokenValue::sym_comma()) {
                        break;
                    }
                }
            }
            parser.consume_sym_or_error(TokenValue::sym_rbracket())?;
            st.set_attr(ARM_PROC_ATTR_INPUTS_REGS, ArrayAttr::new(regs));
        }

        // parse the optional outputs registers
        if parser.try_consume_identifier_val("outs") {
            let mut regs = Vec::new();
            parser.consume_sym_or_error(TokenValue::sym_lbracket())?;
            if !parser.next_token_is_sym(TokenValue::sym_rbracket()) {
                loop {
                    regs.push(parse_short_form_register(parser)?);
                    if !parser.try_consume_sym(TokenValue::sym_comma()) {
                        break;
                    }
                }
            }
            parser.consume_sym_or_error(TokenValue::sym_rbracket())?;
            st.set_attr(ARM_PROC_ATTR_OUTPUTS_REGS, ArrayAttr::new(regs));
        }

        // Parse the optional frame_size.
        if parser.try_consume_identifier_val("frame_size") {
            parser.consume_sym_or_error(TokenValue::sym_assign())?;
            let frame_size = parser.consume_int_or_error()?.get_int().unwrap();
            let frame_size = IntegerAttr::new(frame_size, IntegerType::index_type());
            st.set_attr(ARM_PROC_ATTR_FRAME_SIZE, frame_size);
        }

        // Parse the body
        let mut block_st = BlockParserState::new();
        block_st.set_operands_names(vec![]);
        block_st.set_operands_types(vec![]);
        parser.consume_sym_or_error(TokenValue::sym_lcbracket())?;
        block_st.set_loc(parser.get_next_token_loc());
        let block = parser.make_block_from_state(block_st, ctx, TokenValue::sym_rcbracket())?;

        // Set the block.
        st.set_blocks(vec![block]);
        Some(())
    }
}

impl ArmProcOp<'_> {
    pub fn build<S: Into<StringAttr>>(
        symbol_name: S,
        inputs_regs: Option<Vec<Attribute>>,
        outputs_regs: Option<Vec<Attribute>>,
        frame_size: Option<u64>,
    ) -> OpImplBuilderState<Self> {
        let symbol_name = Attribute::Str(symbol_name.into());
        let mut st = OpImplBuilderState::make();
        st.set_attr(ARM_PROC_ATTR_SYMBOL_NAME, symbol_name);

        if let Some(inputs_regs) = inputs_regs {
            st.set_attr(ARM_PROC_ATTR_INPUTS_REGS, ArrayAttr::new(inputs_regs));
        }

        if let Some(outputs_regs) = outputs_regs {
            st.set_attr(ARM_PROC_ATTR_OUTPUTS_REGS, ArrayAttr::new(outputs_regs));
        }

        if let Some(frame_size) = frame_size {
            st.set_attr(
                ARM_PROC_ATTR_FRAME_SIZE,
                IntegerAttr::new(frame_size, IntegerType::index_type()),
            );
        }

        st
    }
}

/////////////////////////////////////////////////////////////////////////
// ArmAddIns implementation
/////////////////////////////////////////////////////////////////////////

// @XGENDEF:SIROp ArmAddIns
// @opname "arm.add"
// @+attr RegisterAttr<"result">
// @+attr RegisterAttr<"lhs">
// @+attr RegisterOrImmAttr<"rhs">
// @custom_print_parse

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const ARM_ADD_INS_OPNAME: &'static str = "arm.add";
const ARM_ADD_INS_TYPE_UID: OperationTypeUID =
    OperationTypeUID::make_from_opname(ARM_ADD_INS_OPNAME);

pub struct ArmAddIns<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for ArmAddIns<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        ARM_ADD_INS_TYPE_UID
    }
}

const ARM_ADD_INS_ATTR_RESULT: &'static str = "result";
const ARM_ADD_INS_ATTR_LHS: &'static str = "lhs";
const ARM_ADD_INS_ATTR_RHS: &'static str = "rhs";

impl<'a> ArmAddIns<'a> {
    pub fn get_result(&self) -> &'a RegisterAttr {
        self.get_attr(ARM_ADD_INS_ATTR_RESULT)
            .expect("Missing `result` attribute")
            .cast::<RegisterAttr>()
            .expect("`result` attribute must be a register attribute")
    }

    pub fn get_result_attr(&self) -> &'a Attribute {
        self.get_attr(ARM_ADD_INS_ATTR_RESULT)
            .expect("Missing `result` attribute")
    }

    pub fn get_lhs(&self) -> &'a RegisterAttr {
        self.get_attr(ARM_ADD_INS_ATTR_LHS)
            .expect("Missing `lhs` attribute")
            .cast::<RegisterAttr>()
            .expect("`lhs` attribute must be a register attribute")
    }

    pub fn get_lhs_attr(&self) -> &'a Attribute {
        self.get_attr(ARM_ADD_INS_ATTR_LHS)
            .expect("Missing `lhs` attribute")
    }

    pub fn get_rhs(&self) -> &'a Attribute {
        self.get_attr(ARM_ADD_INS_ATTR_RHS)
            .expect("Missing `rhs` attribute")
    }

    pub fn get_rhs_attr(&self) -> &'a Attribute {
        self.get_attr(ARM_ADD_INS_ATTR_RHS)
            .expect("Missing `rhs` attribute")
    }
}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct ArmAddInsBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for ArmAddInsBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) -> ErrorOrSuccess {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ArmAddIns>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ArmAddIns>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        ArmAddIns::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        ArmAddIns::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for ArmAddInsBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> ArmAddIns<'a> {
    pub fn build(result: Attribute, lhs: Attribute, rhs: Attribute) -> OpImplBuilderState<Self> {
        let mut st = OpImplBuilderState::make();
        st.set_attr(ARM_ADD_INS_ATTR_RESULT, result);
        st.set_attr(ARM_ADD_INS_ATTR_LHS, lhs);
        st.set_attr(ARM_ADD_INS_ATTR_RHS, rhs);
        st
    }
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        ir_checks::verif_inputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_ADD_INS_ATTR_RESULT,
            |attr| ir_backend_checks::pred_is_valid_register_attr(self.get_context(), attr),
            "register",
        )?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_ADD_INS_ATTR_LHS,
            |attr| ir_backend_checks::pred_is_valid_register_attr(self.get_context(), attr),
            "register",
        )?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_ADD_INS_ATTR_RHS,
            |attr| ir_backend_checks::pred_is_valid_register_attr_or_imm(self.get_context(), attr),
            "register or immediate",
        )?;
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 0)?;
        Ok(())
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(ArmAddInsBuiltinOpInterfaceImpl))
    }
}

fn register_arm_add_ins_op(ctx: &mut ContextRegistry) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(ARM_ADD_INS_OPNAME);
    infos.set_impl::<ArmAddIns>();
    infos.set_builtin_interface::<ArmAddInsBuiltinOpInterfaceImpl>();
    infos.add_interface::<ArmAddInsBuiltinOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

// BuiltinOp interface implementation for ArmAddIns.
impl<'a> ArmAddIns<'a> {
    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_results_and_opname(self.generic(), true)?;

        print_short_form_register(self.get_result(), printer)?;
        write!(printer.os(), ", ")?;
        print_short_form_register(self.get_lhs(), printer)?;
        write!(printer.os(), ", ")?;
        print_short_form_register_or_immediate(self.get_rhs(), printer)
    }

    pub fn custom_parse(
        parser: &mut IRParser,
        _ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        // Parse all 3 attributes.
        let res_attr = parse_short_form_register(parser)?;
        parser.consume_sym_or_error(TokenValue::sym_comma())?;
        let lhs_attr = parse_short_form_register(parser)?;
        parser.consume_sym_or_error(TokenValue::sym_comma())?;
        let rhs_attr = parse_short_form_register_or_immediate(parser)?;

        st.set_attr(ARM_ADD_INS_ATTR_RESULT, res_attr);
        st.set_attr(ARM_ADD_INS_ATTR_LHS, lhs_attr);
        st.set_attr(ARM_ADD_INS_ATTR_RHS, rhs_attr);
        Some(())
    }
}

/////////////////////////////////////////////////////////////////////////
// ArmSubIns implementation
/////////////////////////////////////////////////////////////////////////

// @XGENDEF:SIROp ArmSubIns
// @opname "arm.sub"
// @+attr RegisterAttr<"result">
// @+attr RegisterAttr<"lhs">
// @+attr RegisterOrImmAttr<"rhs">
// @custom_print_parse

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const ARM_SUB_INS_OPNAME: &'static str = "arm.sub";
const ARM_SUB_INS_TYPE_UID: OperationTypeUID =
    OperationTypeUID::make_from_opname(ARM_SUB_INS_OPNAME);

pub struct ArmSubIns<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for ArmSubIns<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        ARM_SUB_INS_TYPE_UID
    }
}

const ARM_SUB_INS_ATTR_RESULT: &'static str = "result";
const ARM_SUB_INS_ATTR_LHS: &'static str = "lhs";
const ARM_SUB_INS_ATTR_RHS: &'static str = "rhs";

impl<'a> ArmSubIns<'a> {
    pub fn get_result(&self) -> &'a RegisterAttr {
        self.get_attr(ARM_SUB_INS_ATTR_RESULT)
            .expect("Missing `result` attribute")
            .cast::<RegisterAttr>()
            .expect("`result` attribute must be a register attribute")
    }

    pub fn get_result_attr(&self) -> &'a Attribute {
        self.get_attr(ARM_SUB_INS_ATTR_RESULT)
            .expect("Missing `result` attribute")
    }

    pub fn get_lhs(&self) -> &'a RegisterAttr {
        self.get_attr(ARM_SUB_INS_ATTR_LHS)
            .expect("Missing `lhs` attribute")
            .cast::<RegisterAttr>()
            .expect("`lhs` attribute must be a register attribute")
    }

    pub fn get_lhs_attr(&self) -> &'a Attribute {
        self.get_attr(ARM_SUB_INS_ATTR_LHS)
            .expect("Missing `lhs` attribute")
    }

    pub fn get_rhs(&self) -> &'a Attribute {
        self.get_attr(ARM_SUB_INS_ATTR_RHS)
            .expect("Missing `rhs` attribute")
    }

    pub fn get_rhs_attr(&self) -> &'a Attribute {
        self.get_attr(ARM_SUB_INS_ATTR_RHS)
            .expect("Missing `rhs` attribute")
    }
}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct ArmSubInsBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for ArmSubInsBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) -> ErrorOrSuccess {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ArmSubIns>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ArmSubIns>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        ArmSubIns::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        ArmSubIns::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for ArmSubInsBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> ArmSubIns<'a> {
    pub fn build(result: Attribute, lhs: Attribute, rhs: Attribute) -> OpImplBuilderState<Self> {
        let mut st = OpImplBuilderState::make();
        st.set_attr(ARM_SUB_INS_ATTR_RESULT, result);
        st.set_attr(ARM_SUB_INS_ATTR_LHS, lhs);
        st.set_attr(ARM_SUB_INS_ATTR_RHS, rhs);
        st
    }
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        ir_checks::verif_inputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_SUB_INS_ATTR_RESULT,
            |attr| ir_backend_checks::pred_is_valid_register_attr(self.get_context(), attr),
            "register",
        )?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_SUB_INS_ATTR_LHS,
            |attr| ir_backend_checks::pred_is_valid_register_attr(self.get_context(), attr),
            "register",
        )?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_SUB_INS_ATTR_RHS,
            |attr| ir_backend_checks::pred_is_valid_register_attr_or_imm(self.get_context(), attr),
            "register or immediate",
        )?;
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 0)?;
        Ok(())
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(ArmSubInsBuiltinOpInterfaceImpl))
    }
}

fn register_arm_sub_ins_op(ctx: &mut ContextRegistry) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(ARM_SUB_INS_OPNAME);
    infos.set_impl::<ArmSubIns>();
    infos.set_builtin_interface::<ArmSubInsBuiltinOpInterfaceImpl>();
    infos.add_interface::<ArmSubInsBuiltinOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

// BuiltinOp interface implementation for ArmSubIns.
impl<'a> ArmSubIns<'a> {
    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_results_and_opname(self.generic(), true)?;

        print_short_form_register(self.get_result(), printer)?;
        write!(printer.os(), ", ")?;
        print_short_form_register(self.get_lhs(), printer)?;
        write!(printer.os(), ", ")?;
        print_short_form_register_or_immediate(self.get_rhs(), printer)
    }

    pub fn custom_parse(
        parser: &mut IRParser,
        _ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        // Parse all 3 attributes.
        let res_attr = parse_short_form_register(parser)?;
        parser.consume_sym_or_error(TokenValue::sym_comma())?;
        let lhs_attr = parse_short_form_register(parser)?;
        parser.consume_sym_or_error(TokenValue::sym_comma())?;
        let rhs_attr = parse_short_form_register_or_immediate(parser)?;

        st.set_attr(ARM_ADD_INS_ATTR_RESULT, res_attr);
        st.set_attr(ARM_ADD_INS_ATTR_LHS, lhs_attr);
        st.set_attr(ARM_ADD_INS_ATTR_RHS, rhs_attr);
        Some(())
    }
}

/////////////////////////////////////////////////////////////////////////
// ArmLdrIns implementation
/////////////////////////////////////////////////////////////////////////

// @XGENDEF:SIROp ArmLdrIns
// @opname "arm.ldr"
// @+attr RegisterAttr<"result">
// @+attr RegisterAttr<"addr">
// @+attr Optional<IndexAttr<"offset">>
// @custom_print_parse

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const ARM_LDR_INS_OPNAME: &'static str = "arm.ldr";
const ARM_LDR_INS_TYPE_UID: OperationTypeUID =
    OperationTypeUID::make_from_opname(ARM_LDR_INS_OPNAME);

pub struct ArmLdrIns<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for ArmLdrIns<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        ARM_LDR_INS_TYPE_UID
    }
}

const ARM_LDR_INS_ATTR_RESULT: &'static str = "result";
const ARM_LDR_INS_ATTR_ADDR: &'static str = "addr";
const ARM_LDR_INS_ATTR_OFFSET: &'static str = "offset";

impl<'a> ArmLdrIns<'a> {
    pub fn get_result(&self) -> &'a RegisterAttr {
        self.get_attr(ARM_LDR_INS_ATTR_RESULT)
            .expect("Missing `result` attribute")
            .cast::<RegisterAttr>()
            .expect("`result` attribute must be a register attribute")
    }

    pub fn get_result_attr(&self) -> &'a Attribute {
        self.get_attr(ARM_LDR_INS_ATTR_RESULT)
            .expect("Missing `result` attribute")
    }

    pub fn get_addr(&self) -> &'a RegisterAttr {
        self.get_attr(ARM_LDR_INS_ATTR_ADDR)
            .expect("Missing `addr` attribute")
            .cast::<RegisterAttr>()
            .expect("`addr` attribute must be a register attribute")
    }

    pub fn get_addr_attr(&self) -> &'a Attribute {
        self.get_attr(ARM_LDR_INS_ATTR_ADDR)
            .expect("Missing `addr` attribute")
    }

    pub fn get_offset(&self) -> Option<u64> {
        if self.has_attr(ARM_LDR_INS_ATTR_OFFSET) {
            Some(
                self.get_attr(ARM_LDR_INS_ATTR_OFFSET)
                    .expect("Missing `offset` attribute")
                    .cast::<IntegerAttr>()
                    .expect("`offset` attribute must be an IntegerType")
                    .raw_val(),
            )
        } else {
            None
        }
    }

    pub fn get_offset_attr(&self) -> Option<&'a Attribute> {
        self.get_attr(ARM_LDR_INS_ATTR_OFFSET)
    }
}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct ArmLdrInsBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for ArmLdrInsBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) -> ErrorOrSuccess {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ArmLdrIns>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ArmLdrIns>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        ArmLdrIns::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        ArmLdrIns::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for ArmLdrInsBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> ArmLdrIns<'a> {
    pub fn build(
        result: Attribute,
        addr: Attribute,
        offset: Attribute,
    ) -> OpImplBuilderState<Self> {
        let mut st = OpImplBuilderState::make();
        st.set_attr(ARM_LDR_INS_ATTR_RESULT, result);
        st.set_attr(ARM_LDR_INS_ATTR_ADDR, addr);
        st.set_attr(ARM_LDR_INS_ATTR_OFFSET, offset);
        st
    }
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        ir_checks::verif_inputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_LDR_INS_ATTR_RESULT,
            |attr| ir_backend_checks::pred_is_valid_register_attr(self.get_context(), attr),
            "register",
        )?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_LDR_INS_ATTR_ADDR,
            |attr| ir_backend_checks::pred_is_valid_register_attr(self.get_context(), attr),
            "register",
        )?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_LDR_INS_ATTR_OFFSET,
            |attr| ir_checks::pred_is_index_attribute(attr),
            "index type",
        )?;
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 0)?;
        Ok(())
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(ArmLdrInsBuiltinOpInterfaceImpl))
    }
}

fn register_arm_ldr_ins_op(ctx: &mut ContextRegistry) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(ARM_LDR_INS_OPNAME);
    infos.set_impl::<ArmLdrIns>();
    infos.set_builtin_interface::<ArmLdrInsBuiltinOpInterfaceImpl>();
    infos.add_interface::<ArmLdrInsBuiltinOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

// BuiltinOp interface implementation for ArmLdrIns.
impl<'a> ArmLdrIns<'a> {
    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_results_and_opname(self.generic(), true)?;

        print_short_form_register(self.get_result(), printer)?;
        write!(printer.os(), ", [")?;
        print_short_form_register(self.get_addr(), printer)?;

        if let Some(offset) = self.get_offset() {
            write!(printer.os(), ", #{}", offset)?;
        }

        write!(printer.os(), "]")
    }

    pub fn custom_parse(
        parser: &mut IRParser,
        _ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        // Parse the result.
        let res_attr = parse_short_form_register(parser)?;
        parser.consume_sym_or_error(TokenValue::sym_comma())?;
        st.set_attr(ARM_LDR_INS_ATTR_RESULT, res_attr);

        // Parse the address.
        parser.consume_sym_or_error(TokenValue::sym_lbracket())?;
        let addr_attr = parse_short_form_register(parser)?;
        st.set_attr(ARM_LDR_INS_ATTR_ADDR, addr_attr);

        // Parse the optional offset.
        if parser.try_consume_sym(TokenValue::sym_comma()) {
            parser.consume_sym_or_error(TokenValue::sym_hash())?;
            let offset = parser.consume_int_or_error()?.get_int().unwrap();
            let offset = IntegerAttr::new(offset, IntegerType::index_type());
            st.set_attr(ARM_LDR_INS_ATTR_OFFSET, offset);
        }

        parser.consume_sym_or_error(TokenValue::sym_rbracket())?;
        Some(())
    }
}

/////////////////////////////////////////////////////////////////////////
// ArmLdrIns implementation
/////////////////////////////////////////////////////////////////////////

// @XGENDEF:SIROp ArmStrIns
// @opname "arm.str"
// @+attr RegisterAttr<"value">
// @+attr RegisterAttr<"addr">
// @+attr Optional<IndexAttr<"offset">>
// @custom_print_parse

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const ARM_STR_INS_OPNAME: &'static str = "arm.str";
const ARM_STR_INS_TYPE_UID: OperationTypeUID =
    OperationTypeUID::make_from_opname(ARM_STR_INS_OPNAME);

pub struct ArmStrIns<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for ArmStrIns<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        ARM_STR_INS_TYPE_UID
    }
}

const ARM_STR_INS_ATTR_VALUE: &'static str = "value";
const ARM_STR_INS_ATTR_ADDR: &'static str = "addr";
const ARM_STR_INS_ATTR_OFFSET: &'static str = "offset";

impl<'a> ArmStrIns<'a> {
    pub fn get_value(&self) -> &'a RegisterAttr {
        self.get_attr(ARM_STR_INS_ATTR_VALUE)
            .expect("Missing `value` attribute")
            .cast::<RegisterAttr>()
            .expect("`value` attribute must be a register attribute")
    }

    pub fn get_value_attr(&self) -> &'a Attribute {
        self.get_attr(ARM_STR_INS_ATTR_VALUE)
            .expect("Missing `value` attribute")
    }

    pub fn get_addr(&self) -> &'a RegisterAttr {
        self.get_attr(ARM_STR_INS_ATTR_ADDR)
            .expect("Missing `addr` attribute")
            .cast::<RegisterAttr>()
            .expect("`addr` attribute must be a register attribute")
    }

    pub fn get_addr_attr(&self) -> &'a Attribute {
        self.get_attr(ARM_STR_INS_ATTR_ADDR)
            .expect("Missing `addr` attribute")
    }

    pub fn get_offset(&self) -> Option<u64> {
        if self.has_attr(ARM_STR_INS_ATTR_OFFSET) {
            Some(
                self.get_attr(ARM_STR_INS_ATTR_OFFSET)
                    .expect("Missing `offset` attribute")
                    .cast::<IntegerAttr>()
                    .expect("`offset` attribute must be an IntegerType")
                    .raw_val(),
            )
        } else {
            None
        }
    }

    pub fn get_offset_attr(&self) -> Option<&'a Attribute> {
        self.get_attr(ARM_STR_INS_ATTR_OFFSET)
    }
}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct ArmStrInsBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for ArmStrInsBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) -> ErrorOrSuccess {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ArmStrIns>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ArmStrIns>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        ArmStrIns::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        ArmStrIns::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for ArmStrInsBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> ArmStrIns<'a> {
    pub fn build(value: Attribute, addr: Attribute, offset: Attribute) -> OpImplBuilderState<Self> {
        let mut st = OpImplBuilderState::make();
        st.set_attr(ARM_STR_INS_ATTR_VALUE, value);
        st.set_attr(ARM_STR_INS_ATTR_ADDR, addr);
        st.set_attr(ARM_STR_INS_ATTR_OFFSET, offset);
        st
    }
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        ir_checks::verif_inputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_STR_INS_ATTR_VALUE,
            |attr| ir_backend_checks::pred_is_valid_register_attr(self.get_context(), attr),
            "register",
        )?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_STR_INS_ATTR_ADDR,
            |attr| ir_backend_checks::pred_is_valid_register_attr(self.get_context(), attr),
            "register",
        )?;
        ir_checks::verif_has_attr_as(
            diagnostics,
            self.generic(),
            ARM_STR_INS_ATTR_OFFSET,
            |attr| ir_checks::pred_is_index_attribute(attr),
            "index type",
        )?;
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 0)?;
        Ok(())
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(ArmStrInsBuiltinOpInterfaceImpl))
    }
}

fn register_arm_str_ins_op(ctx: &mut ContextRegistry) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(ARM_STR_INS_OPNAME);
    infos.set_impl::<ArmStrIns>();
    infos.set_builtin_interface::<ArmStrInsBuiltinOpInterfaceImpl>();
    infos.add_interface::<ArmStrInsBuiltinOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

// BuiltinOp interface implementation for ArmStrIns.
impl<'a> ArmStrIns<'a> {
    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_results_and_opname(self.generic(), true)?;

        print_short_form_register(self.get_value(), printer)?;
        write!(printer.os(), ", [")?;
        print_short_form_register(self.get_addr(), printer)?;

        if let Some(offset) = self.get_offset() {
            write!(printer.os(), ", #{}", offset)?;
        }

        write!(printer.os(), "]")
    }

    pub fn custom_parse(
        parser: &mut IRParser,
        _ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        // Parse the value.
        let res_attr = parse_short_form_register(parser)?;
        parser.consume_sym_or_error(TokenValue::sym_comma())?;
        st.set_attr(ARM_STR_INS_ATTR_VALUE, res_attr);

        // Parse the address.
        parser.consume_sym_or_error(TokenValue::sym_lbracket())?;
        let addr_attr = parse_short_form_register(parser)?;
        st.set_attr(ARM_STR_INS_ATTR_ADDR, addr_attr);

        // Parse the optional offset.
        if parser.try_consume_sym(TokenValue::sym_comma()) {
            parser.consume_sym_or_error(TokenValue::sym_hash())?;
            let offset = parser.consume_int_or_error()?.get_int().unwrap();
            let offset = IntegerAttr::new(offset, IntegerType::index_type());
            st.set_attr(ARM_STR_INS_ATTR_OFFSET, offset);
        }

        parser.consume_sym_or_error(TokenValue::sym_rbracket())?;
        Some(())
    }
}

/////////////////////////////////////////////////////////////////////////
// ArmRetIns implementation
/////////////////////////////////////////////////////////////////////////

// @XGENDEF:SIROp ArmRetIns
// @opname "arm.ret"
// @custom_print_parse
// @tags ["TAG_TERMINATOR_OP"]

// @XGENBEGIN

// Code automatically generated by sir_core/scripts/xgen.py

const ARM_RET_INS_OPNAME: &'static str = "arm.ret";
const ARM_RET_INS_TYPE_UID: OperationTypeUID =
    OperationTypeUID::make_from_opname(ARM_RET_INS_OPNAME);

pub struct ArmRetIns<'a> {
    ctx: &'a IRContext,
    data: &'a OperationData,
}

impl<'a> OperationImpl<'a> for ArmRetIns<'a> {
    fn make_from_data(ctx: &'a IRContext, data: &'a OperationData) -> Self {
        Self { ctx, data }
    }

    fn get_op_data(&self) -> &'a OperationData {
        self.data
    }

    fn get_context(&self) -> &'a IRContext {
        self.ctx
    }

    fn get_op_type_uid() -> OperationTypeUID {
        ARM_RET_INS_TYPE_UID
    }
}

impl<'a> ArmRetIns<'a> {}

// Wrapper struct for the BuiltinOp interface implementation.
#[derive(Default)]
pub struct ArmRetInsBuiltinOpInterfaceImpl;

impl BuiltinOpInterfaceImpl for ArmRetInsBuiltinOpInterfaceImpl {
    fn verify<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        diagnostics: &mut DiagnosticsEmitter,
    ) -> ErrorOrSuccess {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ArmRetIns>()
            .unwrap()
            .verify(diagnostics)
    }
    fn custom_print<'a>(
        &self,
        ctx: &'a IRContext,
        data: &'a OperationData,
        printer: &mut IRPrinter,
    ) -> Result<(), std::io::Error> {
        GenericOperation::make_from_data(ctx, data)
            .cast::<ArmRetIns>()
            .unwrap()
            .custom_print(printer)
    }
    fn custom_parse(
        &self,
        parser: &mut IRParser,
        ctx: &mut IRContext,
        st: &mut OperationParserState,
    ) -> Option<()> {
        ArmRetIns::custom_parse(parser, ctx, st)
    }
    fn clone(&self) -> BuiltinOpInterfaceImplWrapper {
        ArmRetIns::clone()
    }
}

// Interface builder for BuiltinOp interface.
impl OpInterfaceBuilder for ArmRetInsBuiltinOpInterfaceImpl {
    type InterfaceObjectType = BuiltinOp<'static>;

    fn build_interface_object() -> Box<dyn OpInterfaceWrapper + 'static> {
        let wrapper = BuiltinOpInterfaceImplWrapper::new(Box::new(Self));
        Box::new(wrapper)
    }
}

impl<'a> ArmRetIns<'a> {
    pub fn build() -> OpImplBuilderState<Self> {
        let st = OpImplBuilderState::make();
        st
    }
    pub fn verify(&self, diagnostics: &mut DiagnosticsEmitter) -> ErrorOrSuccess {
        ir_checks::verif_inputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_outputs_count(diagnostics, self.generic(), 0)?;
        ir_checks::verif_blocks_count(diagnostics, self.generic(), 0)?;
        Ok(())
    }
    pub fn clone() -> BuiltinOpInterfaceImplWrapper {
        BuiltinOpInterfaceImplWrapper::new(Box::new(ArmRetInsBuiltinOpInterfaceImpl))
    }
}

fn register_arm_ret_ins_op(ctx: &mut ContextRegistry) {
    let mut infos = OperationTypeBuilder::new();
    infos.set_opname(ARM_RET_INS_OPNAME);
    infos.set_impl::<ArmRetIns>();
    infos.set_builtin_interface::<ArmRetInsBuiltinOpInterfaceImpl>();
    infos.set_tags(&[TAG_TERMINATOR_OP]);
    infos.add_interface::<ArmRetInsBuiltinOpInterfaceImpl>();
    ctx.register_operation(infos.build());
}

// @XGENEND

// BuiltinOp interface implementation for ArmRetIns.
impl<'a> ArmRetIns<'a> {
    pub fn custom_print(&self, printer: &mut IRPrinter) -> Result<(), std::io::Error> {
        printer.print_op_results_and_opname(self.generic(), true)
    }

    pub fn custom_parse(
        _parser: &mut IRParser,
        _ctx: &mut IRContext,
        _st: &mut OperationParserState,
    ) -> Option<()> {
        Some(())
    }
}

/////////////////////////////////////////////////////////////////////////
// ARMOps Registrations
/////////////////////////////////////////////////////////////////////////

// @XGENBEGIN RegisterOps register_armv86a_ops
pub fn register_armv86a_ops(ctx: &mut IRContext) {
    ContextRegistry::exec_register_fn(ctx, "__sir/ops/register_armv86a_ops", |mut registry| {
        register_arm_proc_op(&mut registry);
        register_arm_add_ins_op(&mut registry);
        register_arm_sub_ins_op(&mut registry);
        register_arm_ldr_ins_op(&mut registry);
        register_arm_str_ins_op(&mut registry);
        register_arm_ret_ins_op(&mut registry);
    });
}

// @XGENEND
